<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2D CAD ãƒ„ãƒ¼ãƒ«</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', sans-serif; background: #f0f0f0; color: #222; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
#header { background: #e2e2e2; border-bottom: 1px solid #bbb; padding: 6px 12px; display: flex; align-items: center; gap: 16px; flex-shrink: 0; }
#header h1 { font-size: 16px; color: #c0392b; font-weight: 700; letter-spacing: 1px; }
.header-info { font-size: 11px; color: #777; margin-left: auto; }
#main { display: flex; flex: 1; overflow: hidden; }
#toolbar { width: 52px; background: #e8e8e8; border-right: 1px solid #bbb; display: flex; flex-direction: column; align-items: center; padding: 8px 4px; gap: 4px; flex-shrink: 0; }
.tool-btn { width: 40px; height: 40px; background: #f5f5f5; border: 1px solid #bbb; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 17px; transition: all 0.15s; position: relative; color: #555; }
.tool-btn:hover { background: #ddd; border-color: #c0392b; color: #222; }
.tool-btn.active { background: #c0392b; border-color: #c0392b; color: #fff; }
.tool-sep { width: 32px; height: 1px; background: #bbb; margin: 2px 0; }
.tool-btn[title]:hover::after { content: attr(title); position: absolute; left: 48px; top: 50%; transform: translateY(-50%); background: #fff; color: #222; padding: 4px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap; z-index: 1000; pointer-events: none; border: 1px solid #c0392b; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
#canvas-container { flex: 1; position: relative; overflow: hidden; background: #d8d8d8; }
#canvas { display: block; cursor: crosshair; }
#panel { width: 220px; background: #e8e8e8; border-left: 1px solid #bbb; display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0; }
.psec { padding: 10px; border-bottom: 1px solid #bbb; }
.ptitle { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #c0392b; margin-bottom: 8px; font-weight: 600; }
.prow { display: flex; align-items: center; margin-bottom: 6px; gap: 6px; }
.plabel { font-size: 11px; color: #666; width: 56px; flex-shrink: 0; }
.pinput { flex: 1; background: #fff; border: 1px solid #bbb; color: #222; padding: 3px 6px; border-radius: 4px; font-size: 12px; }
.pinput:focus { outline: none; border-color: #c0392b; }
.punit { font-size: 11px; color: #888; width: 18px; }
input[type="color"] { width: 32px; height: 24px; padding: 1px; cursor: pointer; border-radius: 4px; border: 1px solid #bbb; background: #fff; }
.layer-item { display: flex; align-items: center; padding: 4px 6px; border-radius: 4px; cursor: pointer; font-size: 12px; gap: 6px; color: #333; }
.layer-item:hover { background: #ddd; }
.layer-item.active { background: #c8c8c8; font-weight: 600; }
.obj-item { display: flex; align-items: center; padding: 3px 6px; border-radius: 4px; cursor: pointer; font-size: 11px; gap: 4px; color: #333; }
.obj-item:hover { background: #ddd; }
.obj-item.selected { background: #c8c8c8; color: #c0392b; }
#statusbar { height: 24px; background: #e2e2e2; border-top: 1px solid #bbb; display: flex; align-items: center; padding: 0 12px; gap: 20px; font-size: 11px; color: #777; flex-shrink: 0; }
#statusbar .val { color: #222; font-family: monospace; }
.btn { background: #ddd; border: 1px solid #bbb; color: #333; padding: 4px 9px; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.15s; }
.btn:hover { background: #c0392b; border-color: #c0392b; color: #fff; }
.btn-row { display: flex; gap: 5px; flex-wrap: wrap; }
#sel-info { font-size:11px; color:#777; }
#sel-detail { font-size:11px; color:#444; margin-top:4px; line-height:1.6; }
</style>
</head>
<body>
<div id="header">
  <h1>2D CAD</h1>
  <div style="display:flex;gap:6px;align-items:center;">
    <button class="btn" onclick="newDoc()">æ–°è¦</button>
    <button class="btn" onclick="printDoc()">å°åˆ·ï¼ˆå®Ÿå¯¸ï¼‰</button>
    <button class="btn" onclick="exportSVG()">SVGå‡ºåŠ›</button>
    <button class="btn" onclick="exportPNG()">PNGå‡ºåŠ›</button>
    <button class="btn" onclick="clearAll()">å…¨å‰Šé™¤</button>
  </div>
  <div class="header-info">ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚ºãƒ¼ãƒ  | ä¸­ãƒœã‚¿ãƒ³/Alt+ãƒ‰ãƒ©ãƒƒã‚°:ãƒ‘ãƒ³ | Del:å‰Šé™¤ | Esc:ã‚­ãƒ£ãƒ³ã‚»ãƒ«</div>
</div>
<div id="main">
  <div id="toolbar">
    <button class="tool-btn active" id="tool-select" title="é¸æŠ (S)" onclick="setTool('select')">â†–</button>
    <div class="tool-sep"></div>
    <button class="tool-btn" id="tool-line" title="ç›´ç·š (L)" onclick="setTool('line')">â•±</button>
    <button class="tool-btn" id="tool-rect" title="çŸ©å½¢ (R)" onclick="setTool('rect')">â–­</button>
    <button class="tool-btn" id="tool-circle" title="å†† (C)" onclick="setTool('circle')">â—‹</button>
    <button class="tool-btn" id="tool-arc" title="å††å¼§ (A)" onclick="setTool('arc')">â—œ</button>
    <button class="tool-btn" id="tool-polyline" title="ãƒãƒªãƒ©ã‚¤ãƒ³ (P)" onclick="setTool('polyline')">âŒ’</button>
    <button class="tool-btn" id="tool-spline" title="ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³æ›²ç·š (B)" onclick="setTool('spline')">âˆ¿</button>
    <button class="tool-btn" id="tool-text" title="ãƒ†ã‚­ã‚¹ãƒˆ (T)" onclick="setTool('text')">T</button>
    <div class="tool-sep"></div>
    <button class="tool-btn" id="tool-measure" title="è¨ˆæ¸¬ (M)" onclick="setTool('measure')">ğŸ“</button>
    <div class="tool-sep"></div>
    <button class="tool-btn" title="å…ƒã«æˆ»ã™ (Ctrl+Z)" onclick="undo()">â†©</button>
    <button class="tool-btn" title="ã‚„ã‚Šç›´ã— (Ctrl+Y)" onclick="redo()">â†ª</button>
  </div>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <div id="panel">
    <div class="psec">
      <div class="ptitle">ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£</div>
      <div class="prow"><span class="plabel">ç·šã®è‰²</span><input type="color" id="p-stroke" value="#000000" onchange="updateProps()"></div>
      <div class="prow"><span class="plabel">å¡—ã‚Šè‰²</span><input type="color" id="p-fill" value="#e8f0e8" onchange="updateProps()"><label style="font-size:11px;color:#666;display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="p-fill-none" checked onchange="updateProps()">ãªã—</label></div>
      <div class="prow"><span class="plabel">ç·šå¹…</span><input type="number" class="pinput" id="p-lw" value="0.5" min="0.1" max="20" step="0.1" onchange="updateProps()"><span class="punit">mm</span></div>
      <div class="prow"><span class="plabel">ç·šç¨®</span>
        <select class="pinput" id="p-dash" onchange="updateProps()" style="padding:2px 4px;">
          <option value="solid">å®Ÿç·š</option>
          <option value="dashed">ç ´ç·š</option>
          <option value="dotted">ç‚¹ç·š</option>
          <option value="dashdot">ä¸€ç‚¹é–ç·š</option>
        </select>
      </div>
    </div>
    <div class="psec">
      <div class="ptitle">é¸æŠæƒ…å ±</div>
      <div id="sel-info">ãªã—</div>
      <div id="sel-detail"></div>
    </div>
    <div class="psec">
      <div class="ptitle">ã‚°ãƒªãƒƒãƒ‰ / ã‚¹ãƒŠãƒƒãƒ—</div>
      <div class="prow"><span class="plabel">ã‚°ãƒªãƒƒãƒ‰</span><input type="number" class="pinput" id="grid-mm" value="10" min="0.1" max="500" step="0.1" onchange="updateGrid()"><span class="punit">mm</span></div>
      <div class="prow"><label style="font-size:11px;color:#666;display:flex;align-items:center;gap:4px;cursor:pointer;"><input type="checkbox" id="snap-grid" checked>ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—</label></div>
      <div class="prow"><label style="font-size:11px;color:#666;display:flex;align-items:center;gap:4px;cursor:pointer;"><input type="checkbox" id="snap-end" checked>ç«¯ç‚¹ã‚¹ãƒŠãƒƒãƒ—</label></div>
      <div class="prow"><label style="font-size:11px;color:#666;display:flex;align-items:center;gap:4px;cursor:pointer;"><input type="checkbox" id="snap-mid" checked>ä¸­ç‚¹ã‚¹ãƒŠãƒƒãƒ—</label></div>
      <div class="prow"><label style="font-size:11px;color:#666;display:flex;align-items:center;gap:4px;cursor:pointer;"><input type="checkbox" id="show-grid" checked onchange="redraw()">ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label></div>
    </div>
    <div class="psec">
      <div class="ptitle">ãƒ“ãƒ¥ãƒ¼</div>
      <div class="prow"><span class="plabel">ã‚ºãƒ¼ãƒ </span><span id="zoom-label" style="font-size:12px;font-family:monospace;color:#222;">100%</span></div>
      <div class="btn-row" style="margin-top:4px;">
        <button class="btn" onclick="zoomFit()">å…¨ä½“è¡¨ç¤º</button>
        <button class="btn" onclick="zoom1()">1:1</button>
      </div>
    </div>
    <div class="psec">
      <div class="ptitle">ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
      <div id="layer-list"></div>
      <div class="btn-row" style="margin-top:6px;">
        <button class="btn" onclick="addLayer()">è¿½åŠ </button>
        <button class="btn" onclick="delLayer()">å‰Šé™¤</button>
      </div>
    </div>
    <div class="psec">
      <div class="ptitle">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§</div>
      <div id="obj-list" style="max-height:180px;overflow-y:auto;"></div>
    </div>
  </div>
</div>
<div id="statusbar">
  <span>X: <span class="val" id="st-x">0.0</span> mm</span>
  <span>Y: <span class="val" id="st-y">0.0</span> mm</span>
  <span>Î”X: <span class="val" id="st-dx">â€”</span></span>
  <span>Î”Y: <span class="val" id="st-dy">â€”</span></span>
  <span>è·é›¢: <span class="val" id="st-dist">â€”</span></span>
  <span>ã‚ºãƒ¼ãƒ : <span class="val" id="st-zoom">100</span>%</span>
  <span>å›³å½¢æ•°: <span class="val" id="st-count">0</span></span>
  <span id="st-tool" style="color:#c0392b;">ãƒ„ãƒ¼ãƒ«: é¸æŠ</span>
</div>
<script>
// ==================== çŠ¶æ…‹ ====================
const PX_PER_MM = 3.7795275591;
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let container = document.getElementById('canvas-container');

let vx = 0, vy = 0, vscale = 1.0; // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ: åŸç‚¹pxãƒ»å€ç‡
let BASE = PX_PER_MM;

let objects = [], layers = [{ id: 1, name: 'ãƒ¬ã‚¤ãƒ¤ãƒ¼ 1', visible: true }];
let curLayer = 1, selIds = new Set();
let hist = [], histIdx = -1, nextId = 1;

let tool = 'select', drawing = false;
let drawStart = null, drawPts = [], firstPt = null;
let mouseW = { x: 0, y: 0 }, snapW = null;
let panning = false, panStart = null, panV0 = null;
let selecting = false, selBox = null;
let moving = false, moveStart = null, moveSnap = null;

let pStroke = '#000000', pFill = '#e8f0e8', pFillNone = true, pLW = 0.5, pDash = 'solid';
let gridMM = 10;

// ==================== åˆæœŸåŒ– ====================
function init() {
  resize();
  window.addEventListener('resize', resize);
  vx = canvas.width / 2;
  vy = canvas.height / 2;
  canvas.addEventListener('mousedown', onMD);
  canvas.addEventListener('mousemove', onMM);
  canvas.addEventListener('mouseup', onMU);
  canvas.addEventListener('wheel', onWheel, { passive: false });
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('dblclick', onDblClick);
  document.addEventListener('keydown', onKey);
  updateLayerList();
  saveHist();
  redraw();
}
function resize() {
  let r = container.getBoundingClientRect();
  canvas.width = r.width; canvas.height = r.height;
  redraw();
}

// ==================== åº§æ¨™å¤‰æ› ====================
function s2w(px, py) { return { x: (px - vx) / (vscale * BASE), y: -(py - vy) / (vscale * BASE) }; }
function w2s(wx, wy) { return { x: vx + wx * vscale * BASE, y: vy - wy * vscale * BASE }; }
function mm2px(mm) { return mm * vscale * BASE; }
function px2mm(px) { return px / (vscale * BASE); }

// ==================== ã‚¹ãƒŠãƒƒãƒ— ====================
function doSnap(wpos, excludeId) {
  let best = { x: wpos.x, y: wpos.y, type: 'free' };
  let thr = px2mm(9);

  if (document.getElementById('snap-end').checked) {
    for (let obj of objects) {
      if (obj.id === excludeId || !layerOf(obj.layer)?.visible) continue;
      for (let sp of endPts(obj)) {
        let d = vdist(wpos, sp);
        if (d < thr) { best = { ...sp, type: 'end' }; thr = d; }
      }
    }
  }
  if (document.getElementById('snap-mid').checked && best.type === 'free') {
    for (let obj of objects) {
      if (obj.id === excludeId || !layerOf(obj.layer)?.visible) continue;
      for (let mp of midPts(obj)) {
        let d = vdist(wpos, mp);
        if (d < thr) { best = { ...mp, type: 'mid' }; thr = d; }
      }
    }
  }
  if (document.getElementById('snap-grid').checked && best.type === 'free') {
    let gx = Math.round(wpos.x / gridMM) * gridMM;
    let gy = Math.round(wpos.y / gridMM) * gridMM;
    best = { x: gx, y: gy, type: 'grid' };
  }
  return best;
}

function endPts(obj) {
  switch (obj.type) {
    case 'line': return [{ x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 }];
    case 'rect': return [
      { x: obj.x, y: obj.y }, { x: obj.x + obj.w, y: obj.y },
      { x: obj.x, y: obj.y + obj.h }, { x: obj.x + obj.w, y: obj.y + obj.h }
    ];
    case 'circle': return [
      { x: obj.cx, y: obj.cy },
      { x: obj.cx + obj.r, y: obj.cy }, { x: obj.cx - obj.r, y: obj.cy },
      { x: obj.cx, y: obj.cy + obj.r }, { x: obj.cx, y: obj.cy - obj.r }
    ];
    case 'polyline': return obj.pts.map(p => ({ ...p }));
    case 'spline': return obj.pts.map(p => ({ ...p }));
    default: return [];
  }
}
function midPts(obj) {
  switch (obj.type) {
    case 'line': return [{ x: (obj.x1 + obj.x2) / 2, y: (obj.y1 + obj.y2) / 2 }];
    case 'rect': return [
      { x: obj.x + obj.w / 2, y: obj.y }, { x: obj.x + obj.w / 2, y: obj.y + obj.h },
      { x: obj.x, y: obj.y + obj.h / 2 }, { x: obj.x + obj.w, y: obj.y + obj.h / 2 }
    ];
    default: return [];
  }
}
function vdist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

// ==================== Catmull-Rom ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³ ====================
// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã®ç‚¹åˆ—ã‚’Canvasã«Catmull-Romæ›²ç·šã§æç”»
function strokeCatmullRom(pts_w, closed) {
  if (pts_w.length < 2) return;
  let sp = pts_w.map(p => w2s(p.x, p.y));
  // ç«¯ç‚¹ã‚’æ‹¡å¼µã—ã¦Catmull-RomãŒç«¯ã¾ã§æ»‘ã‚‰ã‹ã«ãªã‚‹ã‚ˆã†å‡¦ç†
  let ext;
  if (closed && sp.length >= 3) {
    ext = [sp[sp.length - 1], ...sp, sp[0], sp[1]];
  } else {
    // ä¸¡ç«¯ã‚’é¡åƒã§å»¶é•·
    let first = { x: 2*sp[0].x - sp[1].x, y: 2*sp[0].y - sp[1].y };
    let last  = { x: 2*sp[sp.length-1].x - sp[sp.length-2].x, y: 2*sp[sp.length-1].y - sp[sp.length-2].y };
    ext = [first, ...sp, last];
  }
  ctx.moveTo(sp[0].x, sp[0].y);
  let count = closed ? sp.length : sp.length - 1;
  for (let i = 0; i < count; i++) {
    let p0 = ext[i], p1 = ext[i+1], p2 = ext[i+2], p3 = ext[i+3];
    // Catmull-Rom â†’ 3æ¬¡ãƒ™ã‚¸ã‚§å¤‰æ› (alpha=0.5ç›¸å½“ã®å‡ç­‰ç‰ˆ)
    let cp1x = p1.x + (p2.x - p0.x) / 6;
    let cp1y = p1.y + (p2.y - p0.y) / 6;
    let cp2x = p2.x - (p3.x - p1.x) / 6;
    let cp2y = p2.y - (p3.y - p1.y) / 6;
    let ex = closed ? sp[(i+1) % sp.length].x : sp[Math.min(i+1, sp.length-1)].x;
    let ey = closed ? sp[(i+1) % sp.length].y : sp[Math.min(i+1, sp.length-1)].y;
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
  }
  if (closed) ctx.closePath();
}

// Catmull-Rom â†’ SVGãƒ‘ã‚¹æ–‡å­—åˆ—ï¼ˆmmåº§æ¨™ç³»ï¼‰
function catmullRomToSVGPath(pts_w, closed, tx, ty) {
  if (pts_w.length < 2) return '';
  let sp = pts_w; // ãƒ¯ãƒ¼ãƒ«ãƒ‰ï¼ˆmmï¼‰åº§æ¨™ã®ã¾ã¾å¤‰æ›
  let ext;
  if (closed && sp.length >= 3) {
    ext = [sp[sp.length-1], ...sp, sp[0], sp[1]];
  } else {
    let first = { x: 2*sp[0].x - sp[1].x, y: 2*sp[0].y - sp[1].y };
    let last  = { x: 2*sp[sp.length-1].x - sp[sp.length-2].x, y: 2*sp[sp.length-1].y - sp[sp.length-2].y };
    ext = [first, ...sp, last];
  }
  let d = `M ${tx(sp[0].x)} ${ty(sp[0].y)}`;
  let count = closed ? sp.length : sp.length - 1;
  for (let i = 0; i < count; i++) {
    let p0 = ext[i], p1 = ext[i+1], p2 = ext[i+2], p3 = ext[i+3];
    let cp1x = +(p1.x + (p2.x - p0.x) / 6).toFixed(3);
    let cp1y = +(p1.y - (p2.y - p0.y) / 6).toFixed(3); // yè»¸åè»¢ï¼ˆSVGã¯ä¸‹å‘ãï¼‰
    let cp2x = +(p2.x - (p3.x - p1.x) / 6).toFixed(3);
    let cp2y = +(p2.y - (p3.y - p1.y) / 6).toFixed(3);
    let ei = closed ? (i+1) % sp.length : Math.min(i+1, sp.length-1);
    d += ` C ${tx(p1.x+(p2.x-p0.x)/6)} ${ty(p1.y+(p2.y-p0.y)/6)} ${tx(p2.x-(p3.x-p1.x)/6)} ${ty(p2.y-(p3.y-p1.y)/6)} ${tx(sp[ei].x)} ${ty(sp[ei].y)}`;
  }
  if (closed) d += ' Z';
  return d;
}

// ==================== æç”» ====================
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // ç”¨ç´™ã‚¨ãƒªã‚¢ï¼ˆç™½ï¼‰
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (document.getElementById('show-grid')?.checked) drawGrid();
  drawAxes();
  for (let obj of objects) {
    if (!layerOf(obj.layer)?.visible) continue;
    drawObj(obj, selIds.has(obj.id));
  }
  drawPreview();
  if (selecting && selBox) drawSelBox();
  drawSnapIndicator();
  updateStatus();
}

function drawGrid() {
  let minW = s2w(0, canvas.height), maxW = s2w(canvas.width, 0);
  let g = gridMM;
  while (mm2px(g) < 8) g *= 5;
  let sub = g / 5;
  ctx.save();
  if (mm2px(sub) >= 3) {
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.lineWidth = 0.5;
    drawGridLines(sub, minW, maxW);
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 0.5;
  drawGridLines(g, minW, maxW);
  // ç›®ç››ã‚Šãƒ©ãƒ™ãƒ«
  if (mm2px(g) > 50) {
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.font = '9px monospace';
    let sx = Math.floor(minW.x / g) * g;
    for (let x = sx; x <= maxW.x; x += g) {
      let px = w2s(x, 0).x;
      ctx.fillText(x.toFixed(0), px + 2, canvas.height - 3);
    }
    let sy = Math.floor(minW.y / g) * g;
    for (let y = sy; y <= maxW.y; y += g) {
      let py = w2s(0, y).y;
      ctx.fillText(y.toFixed(0), 3, py - 2);
    }
  }
  ctx.restore();
}
function drawGridLines(g, minW, maxW) {
  let sx = Math.floor(minW.x / g) * g;
  for (let x = sx; x <= maxW.x + g; x += g) {
    let px = w2s(x, 0).x;
    ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke();
  }
  let sy = Math.floor(minW.y / g) * g;
  for (let y = sy; y <= maxW.y + g; y += g) {
    let py = w2s(0, y).y;
    ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke();
  }
}
function drawAxes() {
  let o = w2s(0, 0);
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(200,50,50,0.5)';
  ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, canvas.height); ctx.stroke();
  ctx.strokeStyle = 'rgba(30,160,30,0.5)';
  ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(canvas.width, o.y); ctx.stroke();
  ctx.restore();
}

function dashArr(dash, lw) {
  let s = mm2px(lw);
  switch (dash) {
    case 'dashed': return [s * 8, s * 4];
    case 'dotted': return [s, s * 3];
    case 'dashdot': return [s * 12, s * 3, s * 2, s * 3];
    default: return [];
  }
}

function applyStyle(obj, sel) {
  ctx.lineWidth = Math.max(mm2px(obj.lw || 0.5), 0.5);
  ctx.strokeStyle = sel ? '#c0392b' : (obj.stroke || '#000000');
  ctx.fillStyle = obj.fillNone ? 'transparent' : (obj.fill || 'transparent');
  ctx.setLineDash(dashArr(obj.dash || 'solid', obj.lw || 0.5));
}

function drawObj(obj, sel) {
  ctx.save();
  applyStyle(obj, sel);
  switch (obj.type) {
    case 'line': {
      let a = w2s(obj.x1, obj.y1), b = w2s(obj.x2, obj.y2);
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      if (sel) {
        ctx.setLineDash([]); ctx.fillStyle = '#c0392b'; ctx.font = '11px monospace';
        let d = vdist({ x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 });
        let m = w2s((obj.x1 + obj.x2) / 2, (obj.y1 + obj.y2) / 2);
        ctx.fillText(d.toFixed(1) + ' mm', m.x + 4, m.y - 4);
      }
      break;
    }
    case 'rect': {
      let s = w2s(obj.x, obj.y);
      let pw = mm2px(obj.w), ph = mm2px(obj.h);
      ctx.beginPath(); ctx.rect(s.x, s.y - ph, pw, ph);
      if (!obj.fillNone) ctx.fill(); ctx.stroke();
      if (sel) {
        ctx.setLineDash([]); ctx.fillStyle = '#c0392b'; ctx.font = '11px monospace';
        ctx.fillText(`${Math.abs(obj.w).toFixed(1)} x ${Math.abs(obj.h).toFixed(1)} mm`, s.x + 2, s.y - ph - 4);
      }
      break;
    }
    case 'circle': {
      let c = w2s(obj.cx, obj.cy), r = mm2px(obj.r);
      ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
      if (!obj.fillNone) ctx.fill(); ctx.stroke();
      if (sel) {
        ctx.setLineDash([]); ctx.fillStyle = '#c0392b'; ctx.font = '11px monospace';
        ctx.fillText(`R${obj.r.toFixed(1)} / âŒ€${(obj.r*2).toFixed(1)} mm`, c.x + r + 4, c.y);
      }
      break;
    }
    case 'arc': {
      let c = w2s(obj.cx, obj.cy), r = mm2px(obj.r);
      let a1 = -obj.a1 * Math.PI / 180, a2 = -obj.a2 * Math.PI / 180;
      ctx.beginPath(); ctx.arc(c.x, c.y, r, a1, a2, true); ctx.stroke();
      break;
    }
    case 'polyline': {
      if (obj.pts.length < 2) break;
      ctx.beginPath();
      let p0 = w2s(obj.pts[0].x, obj.pts[0].y); ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < obj.pts.length; i++) { let p = w2s(obj.pts[i].x, obj.pts[i].y); ctx.lineTo(p.x, p.y); }
      if (obj.closed) ctx.closePath();
      if (!obj.fillNone && obj.closed) ctx.fill(); ctx.stroke();
      break;
    }
    case 'spline': {
      if (obj.pts.length < 2) break;
      ctx.beginPath();
      strokeCatmullRom(obj.pts, obj.closed);
      if (!obj.fillNone && obj.closed) ctx.fill(); ctx.stroke();
      // åˆ¶å¾¡ç‚¹ã‚’è–„ãè¡¨ç¤ºï¼ˆé¸æŠæ™‚ï¼‰
      if (sel) {
        ctx.save();
        ctx.setLineDash([2, 3]);
        ctx.strokeStyle = 'rgba(192,57,43,0.4)';
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        let p0s = w2s(obj.pts[0].x, obj.pts[0].y); ctx.moveTo(p0s.x, p0s.y);
        for (let i = 1; i < obj.pts.length; i++) { let ps = w2s(obj.pts[i].x, obj.pts[i].y); ctx.lineTo(ps.x, ps.y); }
        ctx.stroke();
        ctx.restore();
      }
      break;
    }
    case 'text': {
      let s = w2s(obj.x, obj.y);
      ctx.setLineDash([]);
      ctx.font = `${mm2px(obj.fs || 5)}px sans-serif`;
      ctx.fillStyle = sel ? '#c0392b' : (obj.stroke || '#000000');
      ctx.fillText(obj.text, s.x, s.y);
      break;
    }
  }
  if (sel) drawHandles(obj);
  ctx.restore();
}

function drawHandles(obj) {
  ctx.save(); ctx.fillStyle = '#c0392b'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.setLineDash([]);
  for (let p of endPts(obj)) {
    let s = w2s(p.x, p.y);
    ctx.beginPath(); ctx.arc(s.x, s.y, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawPreview() {
  if (!drawing) return;
  let mp = snapW || mouseW;
  ctx.save();
  ctx.strokeStyle = pStroke; ctx.lineWidth = Math.max(mm2px(pLW), 0.5);
  ctx.setLineDash(dashArr(pDash, pLW)); ctx.globalAlpha = 0.7;
  switch (tool) {
    case 'line':
      if (drawStart) {
        let s = w2s(drawStart.x, drawStart.y), e = w2s(mp.x, mp.y);
        ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#333'; ctx.font = '11px monospace'; ctx.globalAlpha = 1;
        let d = vdist(drawStart, mp);
        ctx.fillText(d.toFixed(1) + ' mm', e.x + 8, e.y - 4);
      }
      break;
    case 'rect':
      if (drawStart) {
        let s = w2s(drawStart.x, drawStart.y);
        let pw = mm2px(mp.x - drawStart.x), ph = mm2px(mp.y - drawStart.y);
        ctx.strokeRect(s.x, s.y - ph, pw, ph);
        ctx.setLineDash([]); ctx.fillStyle = '#333'; ctx.font = '11px monospace'; ctx.globalAlpha = 1;
        ctx.fillText(`${Math.abs(mp.x-drawStart.x).toFixed(1)} x ${Math.abs(mp.y-drawStart.y).toFixed(1)} mm`, s.x+2, s.y - ph - 4);
      }
      break;
    case 'circle':
      if (drawStart) {
        let c = w2s(drawStart.x, drawStart.y), r = mm2px(vdist(drawStart, mp));
        ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#333'; ctx.font = '11px monospace'; ctx.globalAlpha = 1;
        ctx.fillText(`R${vdist(drawStart, mp).toFixed(1)} mm`, c.x + r + 4, c.y);
      }
      break;
    case 'arc':
      if (drawStart && drawPts.length === 0) {
        let c = w2s(drawStart.x, drawStart.y);
        ctx.setLineDash([]); ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.arc(c.x, c.y, 3, 0, Math.PI * 2); ctx.fill();
      } else if (drawStart && drawPts.length === 1) {
        let c = w2s(drawStart.x, drawStart.y), r = mm2px(vdist(drawStart, drawPts[0]));
        ctx.setLineDash([3,3]); ctx.globalAlpha = 0.2;
        ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI * 2); ctx.stroke();
        let pe = w2s(drawPts[0].x, drawPts[0].y);
        ctx.globalAlpha = 0.7; ctx.setLineDash([]);
        ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.lineTo(pe.x, pe.y); ctx.stroke();
        ctx.fillStyle = '#333'; ctx.globalAlpha = 1; ctx.font = '11px monospace';
        ctx.fillText('çµ‚ç‚¹ã‚¯ãƒªãƒƒã‚¯', c.x + r + 4, c.y - 4);
      } else if (drawStart && drawPts.length === 2) {
        let c = w2s(drawStart.x, drawStart.y), r = mm2px(vdist(drawStart, drawPts[0]));
        let a1 = -Math.atan2(drawPts[0].y - drawStart.y, drawPts[0].x - drawStart.x);
        let a2 = -Math.atan2(mp.y - drawStart.y, mp.x - drawStart.x);
        ctx.beginPath(); ctx.arc(c.x, c.y, r, a1, a2, true); ctx.stroke();
      }
      break;
    case 'polyline':
      if (drawPts.length > 0) {
        ctx.beginPath();
        let p0 = w2s(drawPts[0].x, drawPts[0].y); ctx.moveTo(p0.x, p0.y);
        for (let i = 1; i < drawPts.length; i++) { let p = w2s(drawPts[i].x, drawPts[i].y); ctx.lineTo(p.x, p.y); }
        let e = w2s(mp.x, mp.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        if (drawPts.length >= 3 && vdist(mp, drawPts[0]) < px2mm(12)) {
          ctx.setLineDash([]); ctx.fillStyle = '#27ae60'; ctx.font = '11px monospace';
          ctx.fillText('ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹', e.x + 6, e.y - 4);
        }
      }
      break;
    case 'spline':
      if (drawPts.length > 0) {
        let allPts = [...drawPts, mp];
        // è£œåŠ©ç·šï¼ˆè–„ã„ç›´ç·šï¼‰
        ctx.save();
        ctx.globalAlpha = 0.25; ctx.setLineDash([2,3]);
        ctx.beginPath();
        let sp0 = w2s(drawPts[0].x, drawPts[0].y); ctx.moveTo(sp0.x, sp0.y);
        for (let i = 1; i < drawPts.length; i++) { let sp = w2s(drawPts[i].x, drawPts[i].y); ctx.lineTo(sp.x, sp.y); }
        let spe = w2s(mp.x, mp.y); ctx.lineTo(spe.x, spe.y); ctx.stroke();
        ctx.restore();
        // æ›²ç·šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        if (allPts.length >= 2) {
          ctx.beginPath();
          ctx.globalAlpha = 0.7; ctx.setLineDash(dashArr(pDash, pLW));
          strokeCatmullRom(allPts, false); ctx.stroke();
        }
        // åˆ¶å¾¡ç‚¹ãƒãƒ¼ã‚«ãƒ¼
        ctx.save(); ctx.globalAlpha = 0.6; ctx.setLineDash([]);
        ctx.fillStyle = pStroke;
        for (let pt of drawPts) {
          let ps = w2s(pt.x, pt.y);
          ctx.beginPath(); ctx.arc(ps.x, ps.y, 3, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
        let se = w2s(mp.x, mp.y);
        if (drawPts.length >= 3 && vdist(mp, drawPts[0]) < px2mm(12)) {
          ctx.setLineDash([]); ctx.fillStyle = '#27ae60'; ctx.font = '11px monospace'; ctx.globalAlpha = 1;
          ctx.fillText('ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹', se.x + 6, se.y - 4);
        } else {
          ctx.setLineDash([]); ctx.fillStyle = '#555'; ctx.font = '11px monospace'; ctx.globalAlpha = 1;
          ctx.fillText(`ç‚¹æ•°: ${drawPts.length}  Enter/å³ã‚¯ãƒªãƒƒã‚¯ã§ç¢ºå®š`, se.x + 6, se.y - 4);
        }
      }
      break;
    case 'measure':
      if (drawStart) {
        let s = w2s(drawStart.x, drawStart.y), e = w2s(mp.x, mp.y);
        ctx.strokeStyle = '#e67e22'; ctx.setLineDash([4,3]);
        ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#e67e22'; ctx.font = '13px monospace'; ctx.globalAlpha = 1;
        let d = vdist(drawStart, mp);
        ctx.fillText(d.toFixed(1) + ' mm', (s.x+e.x)/2+6, (s.y+e.y)/2-4);
      }
      break;
  }
  ctx.restore();
}

function drawSelBox() {
  let s = w2s(selBox.x1, selBox.y1), e = w2s(selBox.x2, selBox.y2);
  let x = Math.min(s.x, e.x), y = Math.min(s.y, e.y), w = Math.abs(s.x-e.x), h = Math.abs(s.y-e.y);
  let crossSel = selBox.x1 > selBox.x2;
  ctx.save();
  ctx.strokeStyle = crossSel ? '#e67e22' : 'rgba(0,100,200,0.85)';
  ctx.fillStyle = crossSel ? 'rgba(230,126,34,0.07)' : 'rgba(0,100,200,0.07)';
  ctx.lineWidth = 1; ctx.setLineDash([4,3]);
  ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
  ctx.restore();
}

function drawSnapIndicator() {
  if (!snapW) return;
  let s = w2s(snapW.x, snapW.y);
  ctx.save();
  switch (snapW.type) {
    case 'end':
      ctx.strokeStyle = '#27ae60'; ctx.lineWidth = 1.5;
      ctx.strokeRect(s.x-5, s.y-5, 10, 10); break;
    case 'mid':
      ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(s.x-5,s.y+5); ctx.lineTo(s.x,s.y-5); ctx.lineTo(s.x+5,s.y+5); ctx.closePath(); ctx.stroke(); break;
    case 'grid':
      ctx.strokeStyle = '#3355cc'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(s.x-4,s.y); ctx.lineTo(s.x+4,s.y); ctx.moveTo(s.x,s.y-4); ctx.lineTo(s.x,s.y+4); ctx.stroke(); break;
  }
  ctx.restore();
}

// ==================== ãƒã‚¦ã‚¹ ====================
function getPos(e) { let r = canvas.getBoundingClientRect(); return { px: e.clientX - r.left, py: e.clientY - r.top }; }

function onMD(e) {
  let { px, py } = getPos(e);
  let w = s2w(px, py);
  let sn = doSnap(w);
  snapW = sn;

  if (e.button === 1 || (e.button === 0 && e.altKey)) {
    panning = true; panStart = { px, py }; panV0 = { x: vx, y: vy };
    e.preventDefault(); return;
  }
  if (e.button === 2) {
    if (tool === 'polyline' && drawPts.length >= 2) { finishPoly(false); return; }
    if (tool === 'spline' && drawPts.length >= 2) { finishSpline(false); return; }
    if (drawing) { drawing = false; drawStart = null; drawPts = []; firstPt = null; redraw(); return; }
    if (!e.shiftKey) { selIds.clear(); updateObjList(); updateSelPanel(); redraw(); }
    return;
  }
  if (e.button !== 0) return;

  switch (tool) {
    case 'select': doSelectDown(px, py, w, sn); break;
    case 'line': doLineDown(sn); break;
    case 'rect': doRectDown(sn); break;
    case 'circle': doCircleDown(sn); break;
    case 'arc': doArcDown(sn); break;
    case 'polyline': doPolyDown(sn); break;
    case 'spline': doSplineDown(sn); break;
    case 'text': doTextDown(sn); break;
    case 'measure':
      if (!drawing) { drawing = true; drawStart = { ...sn }; }
      else { drawing = false; drawStart = null; }
      break;
  }
}

function onMM(e) {
  let { px, py } = getPos(e);
  let w = s2w(px, py);
  mouseW = w;
  snapW = doSnap(w);

  if (panning) { vx = panV0.x + px - panStart.px; vy = panV0.y + py - panStart.py; redraw(); return; }
  if (moving && moveStart) {
    let dx = snapW.x - moveStart.x, dy = snapW.y - moveStart.y;
    for (let id of selIds) {
      let obj = objects.find(o => o.id === id);
      let snap_o = moveSnap.find(o => o.id === id);
      if (obj && snap_o) applyMove(obj, snap_o, dx, dy);
    }
    redraw(); return;
  }
  if (selecting) { selBox.x2 = w.x; selBox.y2 = w.y; redraw(); return; }
  redraw();
}

function onMU(e) {
  if (panning) { panning = false; return; }
  let { px, py } = getPos(e);
  let w = s2w(px, py);
  if (moving) { moving = false; moveStart = null; saveHist(); return; }
  if (selecting) {
    selecting = false;
    if (selBox) {
      let x1 = Math.min(selBox.x1, selBox.x2), x2 = Math.max(selBox.x1, selBox.x2);
      let y1 = Math.min(selBox.y1, selBox.y2), y2 = Math.max(selBox.y1, selBox.y2);
      let cross = selBox.x1 > selBox.x2;
      for (let obj of objects) {
        if (!layerOf(obj.layer)?.visible) continue;
        if (cross ? objCross(obj, x1, y1, x2, y2) : objInside(obj, x1, y1, x2, y2)) selIds.add(obj.id);
      }
    }
    selBox = null; updateObjList(); updateSelPanel(); redraw();
  }
}

function onDblClick(e) {
  if (tool === 'polyline' && drawPts.length >= 2) finishPoly(false);
  if (tool === 'spline' && drawPts.length >= 2) finishSpline(false);
}

function onWheel(e) {
  e.preventDefault();
  let { px, py } = getPos(e);
  let f = e.deltaY < 0 ? 1.12 : 1/1.12;
  vx = px - (px - vx) * f; vy = py - (py - vy) * f;
  vscale = Math.max(0.01, Math.min(500, vscale * f));
  redraw();
}

// ==================== ãƒ„ãƒ¼ãƒ«æ“ä½œ ====================
function doSelectDown(px, py, w, sn) {
  let picked = pickObj(w);
  if (picked) {
    if (!event.shiftKey && !selIds.has(picked.id)) selIds.clear();
    selIds.add(picked.id);
    moving = true; moveStart = { ...sn };
    moveSnap = objects.map(o => JSON.parse(JSON.stringify(o)));
    updateObjList(); updateSelPanel(); redraw();
  } else {
    if (!event.shiftKey) selIds.clear();
    selecting = true; selBox = { x1: w.x, y1: w.y, x2: w.x, y2: w.y };
    updateObjList(); updateSelPanel(); redraw();
  }
}

function doLineDown(sn) {
  if (!drawing) { drawing = true; drawStart = { ...sn }; firstPt = { ...sn }; }
  else {
    addObj({ id: nextId++, type: 'line', layer: curLayer, x1: drawStart.x, y1: drawStart.y, x2: sn.x, y2: sn.y, stroke: pStroke, lw: pLW, dash: pDash });
    drawStart = { ...sn };
  }
}

function doRectDown(sn) {
  if (!drawing) { drawing = true; drawStart = { ...sn }; firstPt = { ...sn }; }
  else {
    let w = sn.x - drawStart.x, h = sn.y - drawStart.y;
    if (Math.abs(w) < 0.01 || Math.abs(h) < 0.01) { drawing = false; drawStart = null; firstPt = null; return; }
    addObj({ id: nextId++, type: 'rect', layer: curLayer, x: drawStart.x, y: drawStart.y, w, h, stroke: pStroke, fill: pFill, fillNone: pFillNone, lw: pLW, dash: pDash });
    drawing = false; drawStart = null; firstPt = null;
  }
}

function doCircleDown(sn) {
  if (!drawing) { drawing = true; drawStart = { ...sn }; firstPt = { ...sn }; }
  else {
    let r = vdist(drawStart, sn);
    if (r < 0.01) { drawing = false; drawStart = null; firstPt = null; return; }
    addObj({ id: nextId++, type: 'circle', layer: curLayer, cx: drawStart.x, cy: drawStart.y, r, stroke: pStroke, fill: pFill, fillNone: pFillNone, lw: pLW, dash: pDash });
    drawing = false; drawStart = null; firstPt = null;
  }
}

function doArcDown(sn) {
  if (!drawing) { drawing = true; drawStart = { ...sn }; firstPt = { ...sn }; }
  else if (drawPts.length === 0) { drawPts.push({ ...sn }); }
  else if (drawPts.length === 1) {
    let r = vdist(drawStart, drawPts[0]);
    let a1 = Math.atan2(drawPts[0].y - drawStart.y, drawPts[0].x - drawStart.x) * 180 / Math.PI;
    let a2 = Math.atan2(sn.y - drawStart.y, sn.x - drawStart.x) * 180 / Math.PI;
    addObj({ id: nextId++, type: 'arc', layer: curLayer, cx: drawStart.x, cy: drawStart.y, r, a1, a2, stroke: pStroke, lw: pLW, dash: pDash });
    drawing = false; drawStart = null; drawPts = []; firstPt = null;
  }
}

function doPolyDown(sn) {
  if (!drawing) { drawing = true; drawPts = [{ ...sn }]; firstPt = { ...sn }; }
  else {
    if (drawPts.length >= 3 && vdist(sn, drawPts[0]) < px2mm(12)) { finishPoly(true); return; }
    drawPts.push({ ...sn });
  }
}

function finishPoly(closed) {
  if (drawPts.length < 2) { drawing = false; drawPts = []; firstPt = null; return; }
  addObj({ id: nextId++, type: 'polyline', layer: curLayer, pts: drawPts.map(p => ({ ...p })), closed, stroke: pStroke, fill: pFill, fillNone: pFillNone, lw: pLW, dash: pDash });
  drawing = false; drawPts = []; firstPt = null;
}

function doSplineDown(sn) {
  if (!drawing) { drawing = true; drawPts = [{ ...sn }]; firstPt = { ...sn }; }
  else {
    if (drawPts.length >= 3 && vdist(sn, drawPts[0]) < px2mm(12)) { finishSpline(true); return; }
    drawPts.push({ ...sn });
  }
}

function finishSpline(closed) {
  if (drawPts.length < 2) { drawing = false; drawPts = []; firstPt = null; return; }
  addObj({ id: nextId++, type: 'spline', layer: curLayer, pts: drawPts.map(p => ({ ...p })), closed, stroke: pStroke, fill: pFill, fillNone: pFillNone, lw: pLW, dash: pDash });
  drawing = false; drawPts = []; firstPt = null;
}

function doTextDown(sn) {
  let text = prompt('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›:', '');
  if (!text || !text.trim()) return;
  addObj({ id: nextId++, type: 'text', layer: curLayer, x: sn.x, y: sn.y, text: text.trim(), fs: 5, stroke: pStroke });
}

// ==================== ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ ====================
function pickObj(w) {
  let thr = px2mm(7);
  for (let i = objects.length - 1; i >= 0; i--) {
    let obj = objects[i];
    if (!layerOf(obj.layer)?.visible) continue;
    if (hitTest(obj, w, thr)) return obj;
  }
  return null;
}

function hitTest(obj, p, thr) {
  switch (obj.type) {
    case 'line': return distSeg(p, { x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 }) < thr;
    case 'rect': {
      let x2 = obj.x + obj.w, y2 = obj.y + obj.h;
      let onEdge = distSeg(p,{x:obj.x,y:obj.y},{x:x2,y:obj.y})<thr || distSeg(p,{x:x2,y:obj.y},{x:x2,y:y2})<thr || distSeg(p,{x:x2,y:y2},{x:obj.x,y:y2})<thr || distSeg(p,{x:obj.x,y:y2},{x:obj.x,y:obj.y})<thr;
      let inside = !obj.fillNone && p.x>=Math.min(obj.x,x2) && p.x<=Math.max(obj.x,x2) && p.y>=Math.min(obj.y,y2) && p.y<=Math.max(obj.y,y2);
      return onEdge || inside;
    }
    case 'circle': return Math.abs(vdist(p, { x: obj.cx, y: obj.cy }) - obj.r) < thr;
    case 'arc': return Math.abs(vdist(p, { x: obj.cx, y: obj.cy }) - obj.r) < thr;
    case 'polyline': {
      for (let i = 0; i < obj.pts.length - 1; i++) if (distSeg(p, obj.pts[i], obj.pts[i+1]) < thr) return true;
      if (obj.closed && obj.pts.length >= 3) return distSeg(p, obj.pts[obj.pts.length-1], obj.pts[0]) < thr;
      return false;
    }
    case 'spline': {
      // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è¤‡æ•°ã‚µãƒ³ãƒ—ãƒ«ã§è¿‘ä¼¼ã—ã¦ãƒ’ãƒƒãƒˆåˆ¤å®š
      if (obj.pts.length < 2) return false;
      let pts = obj.pts;
      let ext;
      if (obj.closed && pts.length >= 3) {
        ext = [pts[pts.length-1], ...pts, pts[0], pts[1]];
      } else {
        let first = { x: 2*pts[0].x - pts[1].x, y: 2*pts[0].y - pts[1].y };
        let last  = { x: 2*pts[pts.length-1].x - pts[pts.length-2].x, y: 2*pts[pts.length-1].y - pts[pts.length-2].y };
        ext = [first, ...pts, last];
      }
      let count = obj.closed ? pts.length : pts.length - 1;
      for (let i = 0; i < count; i++) {
        let p0=ext[i], p1=ext[i+1], p2=ext[i+2], p3=ext[i+3];
        let cp1x=p1.x+(p2.x-p0.x)/6, cp1y=p1.y+(p2.y-p0.y)/6;
        let cp2x=p2.x-(p3.x-p1.x)/6, cp2y=p2.y-(p3.y-p1.y)/6;
        let ei = obj.closed ? (i+1) % pts.length : Math.min(i+1, pts.length-1);
        let ex=pts[ei].x, ey=pts[ei].y;
        // 20ã‚µãƒ³ãƒ—ãƒ«ã§è¿‘ä¼¼
        let prev = p1;
        for (let j = 1; j <= 20; j++) {
          let t = j / 20;
          let mt = 1-t;
          let nx = mt*mt*mt*p1.x + 3*mt*mt*t*cp1x + 3*mt*t*t*cp2x + t*t*t*ex;
          let ny = mt*mt*mt*p1.y + 3*mt*mt*t*cp1y + 3*mt*t*t*cp2y + t*t*t*ey;
          if (distSeg(p, prev, {x:nx, y:ny}) < thr) return true;
          prev = {x:nx, y:ny};
        }
      }
      return false;
    }
    case 'text': return vdist(p, { x: obj.x, y: obj.y }) < thr * 5;
  }
  return false;
}

function distSeg(p, a, b) {
  let dx = b.x-a.x, dy = b.y-a.y, l2 = dx*dx+dy*dy;
  if (l2 === 0) return vdist(p, a);
  let t = Math.max(0, Math.min(1, ((p.x-a.x)*dx+(p.y-a.y)*dy)/l2));
  return vdist(p, { x: a.x+t*dx, y: a.y+t*dy });
}

function objInside(obj, x1, y1, x2, y2) {
  let pts = endPts(obj);
  return pts.length > 0 && pts.every(p => p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2);
}
function objCross(obj, x1, y1, x2, y2) {
  return endPts(obj).some(p => p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2);
}

function applyMove(obj, snap_o, dx, dy) {
  switch (obj.type) {
    case 'line': obj.x1=snap_o.x1+dx; obj.y1=snap_o.y1+dy; obj.x2=snap_o.x2+dx; obj.y2=snap_o.y2+dy; break;
    case 'rect': obj.x=snap_o.x+dx; obj.y=snap_o.y+dy; break;
    case 'circle': obj.cx=snap_o.cx+dx; obj.cy=snap_o.cy+dy; break;
    case 'arc': obj.cx=snap_o.cx+dx; obj.cy=snap_o.cy+dy; break;
    case 'polyline': obj.pts=snap_o.pts.map(p=>({x:p.x+dx,y:p.y+dy})); break;
    case 'text': obj.x=snap_o.x+dx; obj.y=snap_o.y+dy; break;
  }
}

// ==================== ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç† ====================
function addObj(obj) {
  objects.push(obj);
  saveHist(); updateObjList(); updateCountStatus(); redraw();
}
function deleteSelected() {
  if (!selIds.size) return;
  objects = objects.filter(o => !selIds.has(o.id));
  selIds.clear(); saveHist(); updateObjList(); updateSelPanel(); updateCountStatus(); redraw();
}

// ==================== å±¥æ­´ ====================
function saveHist() {
  hist = hist.slice(0, histIdx + 1);
  hist.push(JSON.stringify(objects));
  histIdx = hist.length - 1;
  if (hist.length > 60) { hist.shift(); histIdx--; }
}
function undo() {
  if (histIdx <= 0) { objects = []; histIdx = 0; hist[0] = '[]'; }
  else histIdx--;
  objects = JSON.parse(hist[histIdx] || '[]');
  selIds.clear(); updateObjList(); updateSelPanel(); updateCountStatus(); redraw();
}
function redo() {
  if (histIdx >= hist.length - 1) return;
  histIdx++; objects = JSON.parse(hist[histIdx]);
  selIds.clear(); updateObjList(); updateSelPanel(); updateCountStatus(); redraw();
}

// ==================== ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ ====================
function onKey(e) {
  if (['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  if (e.key === 'Delete' || e.key === 'Backspace') { deleteSelected(); return; }
  if (e.key === 'Escape') {
    drawing = false; drawStart = null; drawPts = []; firstPt = null;
    selIds.clear(); updateObjList(); updateSelPanel(); redraw(); return;
  }
  if (e.key === 'Enter' && tool === 'polyline' && drawPts.length >= 2) { finishPoly(false); return; }
  if (e.key === 'Enter' && tool === 'spline' && drawPts.length >= 2) { finishSpline(false); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'a') { e.preventDefault(); objects.forEach(o => selIds.add(o.id)); updateObjList(); updateSelPanel(); redraw(); return; }
  const km = { s:'select', l:'line', r:'rect', c:'circle', a:'arc', p:'polyline', b:'spline', t:'text', m:'measure' };
  if (km[e.key.toLowerCase()]) setTool(km[e.key.toLowerCase()]);
}

// ==================== ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ ====================
function setTool(t) {
  tool = t; drawing = false; drawStart = null; drawPts = []; firstPt = null;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  let btn = document.getElementById('tool-' + t); if (btn) btn.classList.add('active');
  const names = { select:'é¸æŠ', line:'ç›´ç·š', rect:'çŸ©å½¢', circle:'å††', arc:'å††å¼§', polyline:'ãƒãƒªãƒ©ã‚¤ãƒ³', spline:'ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³', text:'ãƒ†ã‚­ã‚¹ãƒˆ', measure:'è¨ˆæ¸¬' };
  document.getElementById('st-tool').textContent = 'ãƒ„ãƒ¼ãƒ«: ' + (names[t] || t);
  redraw();
}

// ==================== ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ ====================
function updateProps() {
  pStroke = document.getElementById('p-stroke').value;
  pFill = document.getElementById('p-fill').value;
  pFillNone = document.getElementById('p-fill-none').checked;
  pLW = Math.max(0.1, parseFloat(document.getElementById('p-lw').value) || 0.5);
  pDash = document.getElementById('p-dash').value;
  for (let id of selIds) {
    let obj = objects.find(o => o.id === id); if (!obj) continue;
    obj.stroke = pStroke; obj.fill = pFill; obj.fillNone = pFillNone; obj.lw = pLW; obj.dash = pDash;
  }
  if (selIds.size) saveHist();
  redraw();
}

// ==================== ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ====================
function updateStatus() {
  let sn = snapW || mouseW;
  document.getElementById('st-x').textContent = sn.x.toFixed(1);
  document.getElementById('st-y').textContent = sn.y.toFixed(1);
  if (firstPt || (drawing && drawStart)) {
    let ref = firstPt || drawStart;
    document.getElementById('st-dx').textContent = (sn.x - ref.x).toFixed(1) + ' mm';
    document.getElementById('st-dy').textContent = (sn.y - ref.y).toFixed(1) + ' mm';
    document.getElementById('st-dist').textContent = vdist(ref, sn).toFixed(1) + ' mm';
  } else {
    document.getElementById('st-dx').textContent = 'â€”';
    document.getElementById('st-dy').textContent = 'â€”';
    document.getElementById('st-dist').textContent = 'â€”';
  }
  let pct = Math.round(vscale * 100);
  document.getElementById('st-zoom').textContent = pct;
  document.getElementById('zoom-label').textContent = pct + '%';
}
function updateCountStatus() { document.getElementById('st-count').textContent = objects.length; }

// ==================== é¸æŠãƒ‘ãƒãƒ« ====================
function updateSelPanel() {
  let info = document.getElementById('sel-info');
  let detail = document.getElementById('sel-detail');
  if (!selIds.size) { info.textContent = 'ãªã—'; detail.textContent = ''; return; }
  info.textContent = `${selIds.size}å€‹é¸æŠä¸­`;
  if (selIds.size === 1) {
    let obj = objects.find(o => o.id === [...selIds][0]);
    if (!obj) { detail.textContent = ''; return; }
    let s = '';
    switch (obj.type) {
      case 'line': {
        let d = vdist({x:obj.x1,y:obj.y1},{x:obj.x2,y:obj.y2});
        let ang = Math.atan2(obj.y2-obj.y1, obj.x2-obj.x1)*180/Math.PI;
        s = `ç¨®é¡: ç›´ç·š\nX1:${obj.x1.toFixed(1)} Y1:${obj.y1.toFixed(1)}\nX2:${obj.x2.toFixed(1)} Y2:${obj.y2.toFixed(1)}\né•·ã•: ${d.toFixed(1)} mm\nè§’åº¦: ${ang.toFixed(1)}Â°`; break;
      }
      case 'rect':
        s = `ç¨®é¡: çŸ©å½¢\nX:${obj.x.toFixed(1)} Y:${obj.y.toFixed(1)}\nå¹…:${obj.w.toFixed(1)} é«˜:${obj.h.toFixed(1)} mm\né¢ç©:${Math.abs(obj.w*obj.h).toFixed(2)} mmÂ²`; break;
      case 'circle':
        s = `ç¨®é¡: å††\nä¸­å¿ƒ:${obj.cx.toFixed(1)}, ${obj.cy.toFixed(1)}\nR:${obj.r.toFixed(1)} / âŒ€${(obj.r*2).toFixed(1)} mm\né¢ç©:${(Math.PI*obj.r*obj.r).toFixed(2)} mmÂ²`; break;
      case 'arc':
        s = `ç¨®é¡: å††å¼§\nä¸­å¿ƒ:${obj.cx.toFixed(1)}, ${obj.cy.toFixed(1)}\nR:${obj.r.toFixed(1)} mm`; break;
      case 'polyline':
        s = `ç¨®é¡: ãƒãƒªãƒ©ã‚¤ãƒ³\né ‚ç‚¹æ•°: ${obj.pts.length}\n${obj.closed?'é–‰ã˜ãŸ':'é–‹ã„ãŸ'}ãƒãƒªãƒ©ã‚¤ãƒ³`; break;
      case 'spline':
        s = `ç¨®é¡: ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³æ›²ç·š\nåˆ¶å¾¡ç‚¹æ•°: ${obj.pts.length}\n${obj.closed?'é–‰ã˜ãŸ':'é–‹ã„ãŸ'}ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³`; break;
      case 'text':
        s = `ç¨®é¡: ãƒ†ã‚­ã‚¹ãƒˆ\n"${obj.text}"\nX:${obj.x.toFixed(1)} Y:${obj.y.toFixed(1)}`; break;
    }
    detail.style.whiteSpace = 'pre';
    detail.textContent = s;
  } else { detail.textContent = ''; }
}

// ==================== ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ ====================
const typeIcon = { line:'â•±', rect:'â–­', circle:'â—‹', arc:'â—œ', polyline:'âŒ’', spline:'âˆ¿', text:'T' };
const typeName = { line:'ç›´ç·š', rect:'çŸ©å½¢', circle:'å††', arc:'å††å¼§', polyline:'ãƒãƒªãƒ©ã‚¤ãƒ³', spline:'ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³', text:'ãƒ†ã‚­ã‚¹ãƒˆ' };
function updateObjList() {
  let list = document.getElementById('obj-list');
  list.innerHTML = objects.slice().reverse().map(obj =>
    `<div class="obj-item ${selIds.has(obj.id)?'selected':''}" onclick="clickObj(${obj.id},event)">
      <span style="color:${obj.stroke||'#000'}">${typeIcon[obj.type]||'?'}</span>
      <span>${typeName[obj.type]||obj.type} #${obj.id}</span>
    </div>`
  ).join('');
  updateCountStatus();
}
function clickObj(id, e) {
  if (!e.shiftKey) selIds.clear();
  selIds.add(id); updateObjList(); updateSelPanel(); redraw();
}

// ==================== ãƒ¬ã‚¤ãƒ¤ãƒ¼ ====================
function layerOf(id) { return layers.find(l => l.id === id); }
function updateLayerList() {
  document.getElementById('layer-list').innerHTML = layers.map(l =>
    `<div class="layer-item ${l.id===curLayer?'active':''}" onclick="selectLayer(${l.id})">
      <span onclick="toggleVis(event,${l.id})" style="cursor:pointer;">${l.visible?'ğŸ‘':'ğŸš«'}</span>
      <span style="flex:1;">${l.name}</span>
    </div>`
  ).join('');
}
function selectLayer(id) { curLayer = id; updateLayerList(); }
function toggleVis(e, id) { e.stopPropagation(); let l=layerOf(id); if(l) l.visible=!l.visible; updateLayerList(); redraw(); }
function addLayer() {
  let name = prompt('ãƒ¬ã‚¤ãƒ¤ãƒ¼å:', `ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${layers.length+1}`); if (!name) return;
  let id = Math.max(...layers.map(l=>l.id))+1;
  layers.push({ id, name, visible: true }); curLayer = id; updateLayerList();
}
function delLayer() {
  if (layers.length<=1) { alert('æœ€ä½1ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¿…è¦ã§ã™'); return; }
  if (!confirm(`"${layerOf(curLayer)?.name}" ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) return;
  layers = layers.filter(l=>l.id!==curLayer); curLayer=layers[0].id; updateLayerList(); redraw();
}

// ==================== ã‚°ãƒªãƒƒãƒ‰ ====================
function updateGrid() { gridMM = Math.max(0.1, parseFloat(document.getElementById('grid-mm').value)||10); redraw(); }

// ==================== ã‚ºãƒ¼ãƒ  ====================
function zoomFit() {
  if (!objects.length) { vx=canvas.width/2; vy=canvas.height/2; vscale=1; redraw(); return; }
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for (let obj of objects) {
    let pts = endPts(obj);
    if (obj.type==='circle') pts=[{x:obj.cx-obj.r,y:obj.cy-obj.r},{x:obj.cx+obj.r,y:obj.cy+obj.r}];
    for (let p of pts) { minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y); }
  }
  let pad=30, sw=(canvas.width-pad*2)/((maxX-minX)*BASE||1), sh=(canvas.height-pad*2)/((maxY-minY)*BASE||1);
  vscale = Math.min(sw,sh,200);
  vx = canvas.width/2 - ((minX+maxX)/2)*vscale*BASE;
  vy = canvas.height/2 + ((minY+maxY)/2)*vscale*BASE;
  redraw();
}
function zoom1() { vscale=1; redraw(); }

// ==================== SVGç”Ÿæˆï¼ˆå…±é€šï¼‰ ====================
function buildSVG(whiteBg) {
  if (!objects.length) return null;
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for (let obj of objects) {
    let pts=endPts(obj);
    if (obj.type==='circle') pts=[{x:obj.cx-obj.r,y:obj.cy-obj.r},{x:obj.cx+obj.r,y:obj.cy+obj.r}];
    for (let p of pts){minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}
  }
  let pad=10;
  // SVGã®width/heightã‚’mmå˜ä½ã§æŒ‡å®šâ†’ãƒ–ãƒ©ã‚¦ã‚¶ãŒå°åˆ·æ™‚ã«å®Ÿå¯¸ã§å‡ºåŠ›
  let W=+(maxX-minX+pad*2).toFixed(3), H=+(maxY-minY+pad*2).toFixed(3);
  let tx=x=>(x-minX+pad).toFixed(3), ty=y=>(maxY-y+pad).toFixed(3);
  function da(obj){
    let lw=obj.lw||0.5;
    switch(obj.dash||'solid'){
      case 'dashed':return `stroke-dasharray="${lw*8} ${lw*4}"`;
      case 'dotted':return `stroke-dasharray="${lw} ${lw*3}"`;
      case 'dashdot':return `stroke-dasharray="${lw*12} ${lw*3} ${lw*2} ${lw*3}"`;
      default:return '';
    }
  }
  function cs(obj){return `stroke="${obj.stroke||'#000000'}" stroke-width="${(obj.lw||0.5).toFixed(2)}" fill="${obj.fillNone?'none':(obj.fill||'none')}" ${da(obj)}`;}
  let lines = objects.filter(o=>layerOf(o.layer)?.visible).map(obj=>{
    switch(obj.type){
      case 'line': return `  <line x1="${tx(obj.x1)}" y1="${ty(obj.y1)}" x2="${tx(obj.x2)}" y2="${ty(obj.y2)}" ${cs(obj)}/>`;
      case 'rect': {let x=Math.min(obj.x,obj.x+obj.w),y=Math.min(obj.y,obj.y+obj.h),w=Math.abs(obj.w),h=Math.abs(obj.h); return `  <rect x="${tx(x)}" y="${ty(y+h)}" width="${w.toFixed(3)}" height="${h.toFixed(3)}" ${cs(obj)}/>`;}
      case 'circle': return `  <circle cx="${tx(obj.cx)}" cy="${ty(obj.cy)}" r="${obj.r.toFixed(3)}" ${cs(obj)}/>`;
      case 'arc': {let r=obj.r,a1=obj.a1*Math.PI/180,a2=obj.a2*Math.PI/180,x1=obj.cx+r*Math.cos(a1),y1=obj.cy+r*Math.sin(a1),x2=obj.cx+r*Math.cos(a2),y2=obj.cy+r*Math.sin(a2),lg=Math.abs(a2-a1)>Math.PI?1:0; return `  <path d="M ${tx(x1)} ${ty(y1)} A ${r.toFixed(3)} ${r.toFixed(3)} 0 ${lg} 1 ${tx(x2)} ${ty(y2)}" ${cs(obj)} fill="none"/>`;}
      case 'polyline': {let pts=obj.pts.map(p=>`${tx(p.x)},${ty(p.y)}`).join(' '); return obj.closed?`  <polygon points="${pts}" ${cs(obj)}/>`:`  <polyline points="${pts}" ${cs(obj)} fill="none"/>`;}
      case 'spline': {
        if (obj.pts.length < 2) return '';
        let d = catmullRomToSVGPath(obj.pts, obj.closed, tx, ty);
        return `  <path d="${d}" ${cs(obj)} ${obj.fillNone||!obj.closed?'fill="none"':''}/>`;
      }
      case 'text': return `  <text x="${tx(obj.x)}" y="${ty(obj.y)}" font-size="${(obj.fs||5).toFixed(2)}" fill="${obj.stroke||'#000000'}">${obj.text}</text>`;
      default: return '';
    }
  }).join('\n');
  let bg = whiteBg ? '<rect width="100%" height="100%" fill="white"/>' : '';
  return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${W}mm" height="${H}mm" viewBox="0 0 ${W} ${H}">\n  ${bg}\n${lines}\n</svg>`;
}

// ==================== å°åˆ·ï¼ˆå®Ÿå¯¸mmï¼‰ ====================
function printDoc() {
  if (!objects.length) { alert('å°åˆ·ã™ã‚‹å›³å½¢ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
  let svg = buildSVG(true);
  let win = window.open('', '_blank', 'width=800,height=600');
  win.document.write(`<!DOCTYPE html><html><head><meta charset="UTF-8"><title>å°åˆ·</title>
<style>
  * { margin:0; padding:0; }
  body { background: white; }
  /* SVGã¯mmå˜ä½ã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã®ã§ãƒ–ãƒ©ã‚¦ã‚¶ãŒå®Ÿå¯¸ã§å°åˆ·ã™ã‚‹ */
  img { display: block; }
  @media print {
    body { margin: 0; }
    @page { margin: 10mm; size: auto; }
  }
</style></head><body>
${svg}
<script>window.onload=function(){ window.print(); };<\/script>
</body></html>`);
  win.document.close();
}

// ==================== SVGå‡ºåŠ› ====================
function exportSVG() {
  if (!objects.length) { alert('å›³å½¢ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
  let svg = buildSVG(true);
  let a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([svg],{type:'image/svg+xml'})); a.download='å›³é¢.svg'; a.click();
}

// ==================== PNGå‡ºåŠ› ====================
function exportPNG() {
  let a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='å›³é¢.png'; a.click();
}

// ==================== å›³é¢æ“ä½œ ====================
function newDoc() {
  if (objects.length && !confirm('ç¾åœ¨ã®å›³é¢ã‚’ç ´æ£„ã—ã¦æ–°è¦ä½œæˆã—ã¾ã™ã‹?')) return;
  objects=[]; selIds.clear(); hist=[]; histIdx=-1; nextId=1;
  updateObjList(); updateSelPanel(); updateCountStatus(); redraw();
}
function clearAll() {
  if (!confirm('å…¨å›³å½¢ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) return;
  objects=[]; selIds.clear(); saveHist(); updateObjList(); updateSelPanel(); updateCountStatus(); redraw();
}

// ==================== èµ·å‹• ====================
init();
</script>
</body>
</html>
